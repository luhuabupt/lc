package main

import "fmt"

func main() {
	fmt.Println(countTexts("22233"))
	// [["(","(",")",")","(",")","(",")",")","(","(",")","(",")",")",")",")",")","(",")","(",")",")","(","(","(","(",")","(",")",")",")","(",")",")",")","(",")","(",")","(","(","(",")"],["(",")","(","(","(",")",")",")",")","(","(","(","(",")",")",")","(","(",")","(","(",")",")","(","(",")","(","(","(",")","(","(",")","(",")","(",")","(","(","(","(",")",")","("],["(",")",")","(",")","(",")","(",")",")",")","(","(","(",")",")","(",")",")","(","(",")",")","(","(",")","(",")","(","(","(","(","(","(",")","(",")",")",")",")","(","(","(",")"],[")","(","(",")","(","(",")","(",")","(","(",")",")",")","(",")","(","(",")","(","(","(","(","(","(",")",")","(",")",")","(",")","(","(",")",")",")",")","(","(","(","(",")",")"],[")",")",")","(","(","(","(",")","(","(",")","(",")",")",")",")",")","(",")","(",")","(","(",")","(","(","(",")",")","(","(",")","(","(",")","(",")","(",")","(",")","(",")","("],["(","(","(",")","(","(","(",")",")",")",")",")","(","(","(","(",")",")",")","(",")","(",")","(",")",")",")",")","(","(",")","(","(",")","(","(",")",")","(",")",")","(","(","("],["(",")","(","(","(","(",")",")",")","(",")","(","(",")","(","(","(",")","(",")",")",")","(","(","(",")",")",")","(",")","(","(","(",")",")","(","(",")","(","(",")",")",")","("],[")",")","(","(",")",")","(","(",")","(","(","(",")",")","(",")","(",")",")",")",")",")",")","(",")",")",")","(",")","(","(",")",")",")","(","(",")",")",")",")","(",")","(","("],["(",")",")",")","(",")",")",")","(","(",")","(","(","(",")","(","(",")","(",")","(","(","(",")",")",")","(","(",")","(","(",")","(","(","(","(",")","(","(","(","(",")","(",")"],[")","(","(",")","(",")","(",")","(","(",")",")",")",")","(",")","(","(","(","(",")","(","(",")",")",")",")",")","(","(",")","(",")","(","(",")",")",")","(",")","(","(",")","("],["(",")",")",")","(",")",")",")","(",")",")","(","(","(","(","(","(",")","(",")",")",")","(","(","(","(","(","(","(",")","(",")",")","(","(","(","(","(","(",")","(","(",")",")"]]
	// true
}

func hasValidPath(g [][]byte) bool {
	m, n := len(g), len(g[0])
	if g[0][0] != '(' || g[m-1][n-1] != ')' || (m+n-1)%2 != 0 {
		return false
	}
	ma := (m + n - 1) / 2

	st := [][]int{{0, 0, 1, 0}}
	vis := make([][]map[int]bool, m)
	for i := 0; i < m; i++ {
		vis[i] = make([]map[int]bool, n)
		for j := 0; j < n; j++ {
			vis[i][j] = map[int]bool{}
		}
	}

	for len(st) > 0 {
		ns := [][]int{}
		for _, v := range st {
			if v[0] == m-1 && v[1] == n-1 {
				return true
			}
			for _, d := range [][]int{{0, 1}, {1, 0}} {
				x := []int{v[0] + d[0], v[1] + d[1]}
				if x[0] >= m || x[1] >= n {
					continue
				}

				if g[x[0]][x[1]] == '(' {
					if !vis[x[0]][x[1]][v[2]+1] {
						if v[2] < ma {
							ns = append(ns, []int{x[0], x[1], v[2] + 1, v[3]})
							vis[x[0]][x[1]][v[2]+1] = true
						}
					}
				} else {
					if !vis[x[0]][x[1]][v[2]] {
						if v[3] < v[2] {
							ns = append(ns, []int{x[0], x[1], v[2], v[3] + 1})
							vis[x[0]][x[1]][v[2]] = true
						}
					}
				}
			}
		}

		st = ns
	}
	return false
}

func largestGoodInteger(a string) string {
	ma := ' '
	for i := 0; i < len(a)-3; i++ {
		if a[i] == a[i+1] && a[i] == a[i+2] {
			if int32(a[i]) > ma {
				ma = int32(a[i])
			}
		}
	}
	if ma == ' ' {
		return ""
	}
	return string([]byte{byte(ma), byte(ma), byte(ma)})
}

//
//func averageOfSubtree(root *TreeNode) int {
//	ans := 0
//	var dfs func(p *TreeNode) (int, int)
//	dfs = func(p *TreeNode) (int, int) {
//		if p == nil {
//			return 0, 0
//		}
//		a, al := dfs(p.Left)
//		b, bl := dfs(p.Right)
//		if (a+b+p.Val)/(al+bl+1) == p.Val {
//			ans++
//		}
//		return a + b + p.Val, al + bl + 1
//	}
//	dfs(root)
//	return ans
//}

func countTexts(s string) int {
	chk := func(i, l int) bool {
		if i < l-1 {
			return false
		}
		for j := 0; j < l; j++ {
			if s[i-j] != s[i] {
				return false
			}
		}
		return true
	}

	M := int(1e9 + 7)
	dp := map[int]int{}
	dp[-1] = 1
	for i, v := range s {
		if (v == '7' || v == '9') && chk(i, 4) {
			dp[i] += dp[i-4]
		}
		if chk(i, 3) {
			dp[i] += dp[i-3]
		}
		if chk(i, 2) {
			dp[i] += dp[i-2]
		}
		dp[i] += dp[i-1]
		dp[i] %= M
	}
	return dp[len(s)-1]
}
