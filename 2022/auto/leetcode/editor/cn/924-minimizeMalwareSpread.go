package main

import "fmt"

func main() {
	//fmt.Println(minMalwareSpread([][]int{{1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1}, {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0}, {0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0}, {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0}, {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0}, {0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0}, {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}, []int{7, 8, 6, 2, 3}))

	fmt.Println(minMalwareSpread([][]int{{1, 0, 1, 0}, {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}}, []int{1, 2}))
}

//leetcode submit region begin(Prohibit modification and deletion)
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	im := make([]bool, n)
	ans := n + 1
	for _, v := range initial {
		im[v] = true
		if v < ans {
			ans = v
		}
	}

	uf := newUnionFind(n)

	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			if graph[i][j] == 1 {
				//fmt.Println(i, j)
				uf.union(i, j)
			}
		}
	}

	ma := 0
	for _, so := range uf.son {
		if len(so) > 0 {
			do, x := 0, 0
			for _, v := range so {
				if im[v] {
					x = v
					do++
				}
			}
			if do == 1 {
				if len(so) > ma || len(so) == ma && x < ans {
					ans = x
				}
				ma = len(so)
			}
		}
	}

	return ans
}

type unionFind struct {
	size int
	fa   []int
	son  [][]int
}

func newUnionFind(n int) *unionFind {
	fa := make([]int, n)
	son := make([][]int, n)
	for i := 0; i < n; i++ {
		fa[i] = i
		son[i] = append(son[i], i)
	}
	return &unionFind{n, fa, son}
}

func (t *unionFind) find(i int) int {
	if t.fa[i] == i {
		return i
	}
	return t.find(t.fa[i])
}

func (t *unionFind) union(i, j int) {
	fi, fj := t.find(i), t.find(j)
	if fi == fj {
		return
	}

	if len(t.son[fi]) < len(t.son[fj]) {
		fi, fj = fj, fi
	}

	for _, v := range t.son[fj] {
		t.fa[v] = fi
	}

	t.son[fi] = append(t.son[fi], t.son[fj]...)
	t.son[fj] = []int{}
	t.size--
}

//leetcode submit region end(Prohibit modification and deletion)
